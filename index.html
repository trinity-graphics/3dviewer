<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Object Viewer</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            color: white;
            border-radius: 5px;
        }
        select {
            margin: 5px;
        }
        #info {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            color: white;
            border-radius: 5px;
            max-width: 250px;
        }
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            color: white;
            border-radius: 5px;
            max-width: 300px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <label for="dataset-select">Dataset:</label>
        <select id="dataset-select"></select>
        <br>
        <label for="object-select">Object:</label>
        <select id="object-select"></select>
        <br>
        <label for="view-mode-select">View Mode:</label>
        <select id="view-mode-select">
            <option value="surface">Surface</option>
            <option value="wireframe">Wireframe</option>
            <option value="both">Both</option>
            <option value="components">Components</option>
        </select>
        <br>
        <label style="font-size:12px;margin-top:6px;"><input type="checkbox" id="axes-toggle"> Show axes (X)</label>
        <br>
        <button id="download-btn" style="margin-top:6px;">Download OBJ</button>
        <br>
        <label style="font-size:12px;margin-top:6px;"><input type="checkbox" id="weld-toggle"> Weld nearby vertices (spatial weld)</label>
        <div style="color:#ddd;font-size:12px;margin-top:6px;">View modes: Surface (solid), Wireframe (edges), Both (overlay), Components (color clusters)</div>
    </div>

    <div id="debug-status" style="position:absolute;bottom:10px;right:10px;padding:8px;background:rgba(0,0,0,0.6);color:#0f0;border-radius:4px;font-size:12px;max-width:320px;">
        <div><strong>Debug:</strong></div>
        <div id="debug-msg">waiting for /data...</div>
    </div>

    <div id="info">
        <div><strong>Object Info:</strong></div>
        <div id="vertices-count">Vertices: -</div>
        <div id="faces-count">Faces: -</div>
        <div id="area">Surface area: -</div>
        <div id="volume">Volume: -</div>
        <div id="bbox-min">BBox min: -</div>
        <div id="bbox-max">BBox max: -</div>
        <div id="bbox-size">BBox size: -</div>
        <div id="clusters-count">Clusters: -</div>
        <div id="file-name">File: -</div>
    </div>

    <div id="instructions">
        <div><strong>Controls:</strong></div>
        <div>• J/K/L: Surface / Wireframe / Both</div>
        <div>• C: Toggle Components view</div>
        <div>• X: Toggle Axes</div>
    <div>• B: Toggle Bounding Box</div>
    <div>• D / Shift+D: Download OBJ (button or Shift+D)</div>
    <div>• Weld toggle: Enable spatial weld to merge nearby vertices before computing components (uncheck to use strict vertex connectivity)</div>
        <div><strong>Rotation:</strong></div>
        <div>• A/D: Rotate Y-axis</div>
        <div>• W/S: Rotate X-axis</div>
        <div>• T/G: Rotate Z-axis</div>
        <div><strong>Navigation:</strong></div>
        <div>• ←/→: Previous/Next object</div>
        <div><strong>Mouse:</strong></div>
        <div>• Drag: Orbit camera</div>
        <div>• Scroll: Zoom in/out</div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
    import { OBJLoader } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/loaders/OBJLoader.js';
    import { OrbitControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js';
    import { OBJExporter } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/exporters/OBJExporter.js';

    let scene, camera, renderer, controls, currentObject;
    let axesHelper = null;
    let axesVisible = false;
    let boxHelper = null;
    let bboxVisible = false;

        const datasetSelect = document.getElementById('dataset-select');
        const objectSelect = document.getElementById('object-select');
    const viewModeSelect = document.getElementById('view-mode-select');
    let fileData = {};
    let prevViewMode = null;

    let wireframeObject;
    let downloadBtn = null;
    let weldToggle = null;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xdddddd);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // Create but don't add the axes helper yet; we'll toggle it via checkbox or 'x' key
            axesHelper = new THREE.AxesHelper(1);

            const axesToggle = document.getElementById('axes-toggle');
            axesToggle.addEventListener('change', (e) => {
                axesVisible = !!e.target.checked;
                if (axesVisible) {
                    scene.add(axesHelper);
                } else {
                    scene.remove(axesHelper);
                }
            });

            // Download button wiring
            downloadBtn = document.getElementById('download-btn');
            if (downloadBtn) {
                downloadBtn.disabled = true; // disabled until an object is loaded
                downloadBtn.addEventListener('click', () => downloadCurrentObject());
            }

            // Weld toggle wiring
            weldToggle = document.getElementById('weld-toggle');
            if (weldToggle) {
                // default to welded behavior for backward compatibility
                weldToggle.checked = true;
                // when toggled, if we're in components mode, refresh coloring immediately
                weldToggle.addEventListener('change', () => {
                    if (viewModeSelect && viewModeSelect.value === 'components' && currentObject) {
                        // force re-apply component coloring according to new weld state
                        updateViewMode();
                    }
                });
            }

            animate();
            loadData();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            // update boxHelper if present so it follows object transforms
            if (boxHelper) boxHelper.update();
            renderer.render(scene, camera);
        }

        function loadData() {
            console.info('loadData(): starting fetch /data');
            const debugMsg = document.getElementById('debug-msg');
            debugMsg.textContent = 'fetching /data...';

            // add a cache-busting query and ask fetch to not use cache/service-worker cached responses
            const dataUrl = '/data?bust=' + Date.now();
            fetch(dataUrl, { cache: 'no-store' })
                .then(response => {
                    console.info('loadData(): /data response status', response.status);
                    if (!response.ok) {
                        throw new Error('Server returned ' + response.status);
                    }
                    return response.text().then(text => {
                        // try parse as JSON first; if it looks like HTML, fallback
                        try {
                            return JSON.parse(text);
                        } catch (e) {
                            // If response starts with '<', it's probably HTML (index.html)
                            if (text.trim().startsWith('<')) {
                                throw new Error('non-json-response');
                            }
                            // maybe it's JSON but parse failed due to BOM or similar; rethrow
                            throw e;
                        }
                    });
                })
                .then(data => {
                    console.info('loadData(): parsed JSON', data && Object.keys(data).length);
                    fileData = data;
                    const datasets = Object.keys(data);
                    datasets.forEach(dataset => {
                        const option = document.createElement('option');
                        option.value = dataset;
                        option.textContent = dataset;
                        datasetSelect.appendChild(option);
                    });
                    datasetSelect.dispatchEvent(new Event('change'));
                    debugMsg.textContent = '/data fetched OK';

                    // Now request server-side status to confirm the server saw the request
                    const statusUrl = '/data/status?bust=' + Date.now();
                    fetch(statusUrl, { cache: 'no-store' })
                        .then(r => r.json())
                        .then(status => {
                            console.info('/data/status', status);
                            debugMsg.textContent = '/data status: count=' + status.count + ', last=' + status.last_request_time;
                        })
                        .catch(err => {
                            console.warn('Could not fetch /data/status', err);
                            debugMsg.textContent = '/data fetched but /data/status failed';
                        });
                })
                .catch(err => {
                    console.error('loadData(): failed to fetch /data', err);
                    // If error indicates HTML was returned, try the fallback
                    if (err && err.message === 'non-json-response') {
                        debugMsg.textContent = '/data returned HTML; trying fallback /data_files.json';
                        fetch('/data_files.json', { cache: 'no-store' })
                            .then(r => {
                                if (!r.ok) throw new Error('fallback returned ' + r.status);
                                return r.json();
                            })
                            .then(fallbackData => {
                                console.info('Fallback data_files.json loaded', fallbackData && Object.keys(fallbackData).length);
                                fileData = fallbackData;
                                const datasets = Object.keys(fallbackData);
                                datasets.forEach(dataset => {
                                    const option = document.createElement('option');
                                    option.value = dataset;
                                    option.textContent = dataset;
                                    datasetSelect.appendChild(option);
                                });
                                datasetSelect.dispatchEvent(new Event('change'));
                                debugMsg.textContent = 'Fallback loaded /data_files.json';
                            })
                            .catch(ferr => {
                                console.error('Fallback failed', ferr);
                                debugMsg.textContent = 'ERROR fallback /data_files.json: ' + ferr.message;
                            });
                        return;
                    }

                    debugMsg.textContent = 'ERROR fetching /data: ' + err.message;
                });
        }

        datasetSelect.addEventListener('change', () => {
            const selectedDataset = datasetSelect.value;
            const objects = fileData[selectedDataset];
            objectSelect.innerHTML = '';
            objects.forEach(objectPath => {
                const option = document.createElement('option');
                option.value = objectPath;
                const fileName = objectPath.split('/').pop();
                option.textContent = fileName;
                objectSelect.appendChild(option);
            });
            objectSelect.dispatchEvent(new Event('change'));
        });

        objectSelect.addEventListener('change', () => {
            const selectedObjectPath = objectSelect.value;
            if (selectedObjectPath) {
                loadObject(selectedObjectPath);
            }
        });

        viewModeSelect.addEventListener('change', () => {
            updateViewMode();
        });

        function updateViewMode() {
            if (wireframeObject) {
                scene.remove(wireframeObject);
                wireframeObject = null;
            }

            if (!currentObject) return;

            const mode = viewModeSelect.value;

            // Clear any component-coloring metadata
            if (currentObject._componentColorBackup) {
                // restore original material per mesh
                currentObject.traverse((child) => {
                    if (child.isMesh && child._originalMaterial) {
                        child.material = child._originalMaterial;
                        delete child._originalMaterial;
                    }
                });
                delete currentObject._componentColorBackup;
            }

            // Make sure to set the material on all meshes
            currentObject.traverse((child) => {
                if (child.isMesh) {
                    child.material.wireframe = (mode === 'wireframe');
                }
            });

            if (mode === 'both') {
                 currentObject.traverse((child) => {
                    if (child.isMesh) {
                        child.material.wireframe = false;
                    }
                });

                wireframeObject = currentObject.clone();
                const wireframeMaterial = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    wireframe: true,
                    side: THREE.DoubleSide,
                    depthTest: false,
                    depthWrite: false,
                    transparent: true,
                });

                wireframeObject.traverse((child) => {
                    if (child.isMesh) {
                        child.material = wireframeMaterial;
                    }
                });
                scene.add(wireframeObject);
                // draw wireframe on top to avoid z-fighting with the solid mesh
                wireframeObject.traverse((c) => {
                    if (c.isMesh) {
                        c.renderOrder = 999;
                        if (c.material) {
                            c.material.depthTest = false;
                            c.material.depthWrite = false;
                            c.material.transparent = true;
                        }
                    }
                });
            }

            if (mode === 'components') {
                // Color each strongly connected component with a distinct color.
                applyComponentColors(currentObject);
            }
        }

        function downloadCurrentObject() {
            if (!currentObject) {
                alert('No object loaded to download.');
                return;
            }
            try {
                const exporter = new OBJExporter();
                // exporter.parse returns a string containing the OBJ data
                const objText = exporter.parse(currentObject);
                const blob = new Blob([objText], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                const name = (document.getElementById('file-name') && document.getElementById('file-name').textContent.replace('File: ', '')) || 'model.obj';
                a.href = url;
                a.download = name.endsWith('.obj') ? name : (name + '.obj');
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
            } catch (err) {
                console.error('Failed to export OBJ', err);
                alert('Export failed: ' + (err && err.message ? err.message : String(err)));
            }
        }

        function applyComponentColors(rootObject) {
            // For each mesh in the object, compute connected components of its geometry
            // and assign a different color to faces belonging to different components.
            // We handle BufferGeometry (indexed or non-indexed).
            rootObject.traverse((mesh) => {
                if (!mesh.isMesh || !mesh.geometry) return;

                const geom = mesh.geometry;
                const pos = geom.attributes.position;
                if (!pos) return;

                // Backup original material so we can restore later
                mesh._originalMaterial = mesh.material;

                // Build world-space positions array
                const vertexCount = pos.count;
                const worldPos = new Array(vertexCount);
                const tmp = new THREE.Vector3();
                for (let i = 0; i < vertexCount; i++) {
                    tmp.fromBufferAttribute(pos, i);
                    mesh.localToWorld(tmp);
                    worldPos[i] = tmp.clone();
                }

                // Determine representatives and connectivity.
                // If weldToggle is checked (default), perform spatial welding (existing behavior).
                // If weldToggle is unchecked, use exact vertex connectivity: vertices are only
                // unified when they are identical indices referenced by the same triangles.
                const doWeld = !(weldToggle && weldToggle.checked === false);

                let rep, repCount;
                if (doWeld) {
                    // Spatial hash / weld nearby vertices within epsilon
                    const eps = 1e-4; // tolerance; adjust if needed
                    const grid = new Map();
                    rep = new Uint32Array(vertexCount);
                    repCount = 0;
                    for (let i = 0; i < vertexCount; i++) {
                        const v = worldPos[i];
                        const kx = Math.round(v.x / eps);
                        const ky = Math.round(v.y / eps);
                        const kz = Math.round(v.z / eps);
                        const key = kx + '_' + ky + '_' + kz;
                        if (grid.has(key)) {
                            rep[i] = grid.get(key);
                        } else {
                            grid.set(key, repCount);
                            rep[i] = repCount;
                            repCount++;
                        }
                    }
                } else {
                    // No welding: each vertex index is its own representative initially
                    rep = new Uint32Array(vertexCount);
                    for (let i = 0; i < vertexCount; i++) rep[i] = i;
                    repCount = vertexCount;
                }

                // Union-find over representatives
                const parent = new Uint32Array(repCount);
                for (let i = 0; i < repCount; i++) parent[i] = i;
                function find(a) { while (parent[a] !== a) { parent[a] = parent[parent[a]]; a = parent[a]; } return a; }
                function union(a,b) { const ra = find(a), rb = find(b); if (ra!==rb) parent[rb]=ra; }

                const index = geom.index ? Array.from(geom.index.array) : null;
                if (index) {
                    for (let i = 0; i < index.length; i += 3) {
                        const ia = index[i], ib = index[i+1], ic = index[i+2];
                        const a = rep[ia];
                        const b = rep[ib];
                        const c = rep[ic];
                        union(a,b); union(b,c); union(c,a);
                    }
                } else {
                    // Non-indexed geometry: triangles are sequential vertices
                    for (let i = 0; i < vertexCount; i += 3) {
                        const a = rep[i], b = rep[i+1], c = rep[i+2];
                        union(a,b); union(b,c); union(c,a);
                    }
                }

                // Map root -> component id
                const compId = new Map();
                let compCount = 0;
                for (let i = 0; i < repCount; i++) {
                    const r = find(i);
                    if (!compId.has(r)) compId.set(r, compCount++);
                }

                // Create a color array per vertex (RGB floats) based on component of its representative
                const colors = new Float32Array(vertexCount * 3);
                for (let i = 0; i < vertexCount; i++) {
                    const cid = compId.get(find(rep[i]));
                    const hue = (cid * 0.618033988749895) % 1.0;
                    const col = new THREE.Color().setHSL(hue, 0.6, 0.5);
                    colors[i*3] = col.r;
                    colors[i*3+1] = col.g;
                    colors[i*3+2] = col.b;
                }

                geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                // Use MeshPhongMaterial (or clone original) but enable vertexColors
                const mat = mesh.material && mesh.material.clone ? mesh.material.clone() : new THREE.MeshPhongMaterial();
                mat.vertexColors = true;
                // Ensure faces aren't hidden due to backface culling or missing normals
                mat.side = THREE.DoubleSide;
                mesh.material = mat;
                // Mark that we applied component coloring
                rootObject._componentColorBackup = true;
                // return component count for this mesh (we'll map reps to ids earlier)
                mesh._componentCount = compCount;
            });
            // set clusters count total across meshes
            let totalClusters = 0;
            rootObject.traverse((m) => { if (m._componentCount) totalClusters += m._componentCount; });
            document.getElementById('clusters-count').textContent = `Clusters: ${totalClusters}`;
        }

        function updateObjectInfo(object) {
            // Computes vertex count, face count, surface area and approximate volume.
            let totalVertices = 0;
            let totalFaces = 0;
            let totalArea = 0; // surface area
            let signedVolume = 0; // signed volume from triangles (w.r.t origin)

            const vA = new THREE.Vector3();
            const vB = new THREE.Vector3();
            const vC = new THREE.Vector3();
            const ab = new THREE.Vector3();
            const cb = new THREE.Vector3();
            const cross = new THREE.Vector3();
            const cross2 = new THREE.Vector3();

            object.updateMatrixWorld(true);

            object.traverse((child) => {
                if (!child.isMesh || !child.geometry) return;

                const geom = child.geometry;
                const position = geom.attributes.position;
                if (!position) return;

                const index = geom.index ? geom.index.array : null;

                totalVertices += position.count;

                const fetchAndWorld = (idx, target) => {
                    target.fromBufferAttribute(position, idx);
                    child.localToWorld(target);
                };

                if (index) {
                    totalFaces += index.length / 3;
                    for (let i = 0; i < index.length; i += 3) {
                        fetchAndWorld(index[i], vA);
                        fetchAndWorld(index[i+1], vB);
                        fetchAndWorld(index[i+2], vC);

                        // area: 0.5 * |(B-A) x (C-A)|
                        ab.subVectors(vB, vA);
                        cb.subVectors(vC, vA);
                        cross.crossVectors(ab, cb);
                        totalArea += 0.5 * cross.length();

                        // signed volume: (1/6) * dot(A, B x C)
                        cross2.crossVectors(vB, vC);
                        signedVolume += vA.dot(cross2) / 6.0;
                    }
                } else {
                    const posCount = position.count;
                    totalFaces += posCount / 3;
                    for (let i = 0; i < posCount; i += 3) {
                        fetchAndWorld(i, vA);
                        fetchAndWorld(i+1, vB);
                        fetchAndWorld(i+2, vC);

                        ab.subVectors(vB, vA);
                        cb.subVectors(vC, vA);
                        cross.crossVectors(ab, cb);
                        totalArea += 0.5 * cross.length();

                        cross2.crossVectors(vB, vC);
                        signedVolume += vA.dot(cross2) / 6.0;
                    }
                }
            });

            const volume = Math.abs(signedVolume);

            document.getElementById('vertices-count').textContent = `Vertices: ${totalVertices.toLocaleString()}`;
            document.getElementById('faces-count').textContent = `Faces: ${Math.floor(totalFaces).toLocaleString()}`;
            document.getElementById('area').textContent = `Surface area: ${totalArea.toFixed(3)}`;
            document.getElementById('volume').textContent = `Volume: ${volume.toFixed(3)}`;

            // compute and display bounding box info (in world space) only when visible
            if (bboxVisible) {
                const box = new THREE.Box3().setFromObject(object);
                const min = box.min;
                const max = box.max;
                const size = box.getSize(new THREE.Vector3());
                document.getElementById('bbox-min').textContent = `BBox min: (${min.x.toFixed(4)}, ${min.y.toFixed(4)}, ${min.z.toFixed(4)})`;
                document.getElementById('bbox-max').textContent = `BBox max: (${max.x.toFixed(4)}, ${max.y.toFixed(4)}, ${max.z.toFixed(4)})`;
                document.getElementById('bbox-size').textContent = `BBox size: (${size.x.toFixed(4)}, ${size.y.toFixed(4)}, ${size.z.toFixed(4)})`;
            } else {
                document.getElementById('bbox-min').textContent = `BBox min: -`;
                document.getElementById('bbox-max').textContent = `BBox max: -`;
                document.getElementById('bbox-size').textContent = `BBox size: -`;
            }
        }

        function loadObject(path) {
            if (currentObject) {
                scene.remove(currentObject);
                currentObject = null;
            }
            if (wireframeObject) {
                scene.remove(wireframeObject);
                wireframeObject = null;
            }
            if (downloadBtn) downloadBtn.disabled = true;
            const loader = new OBJLoader();
            loader.load(
                `/object?path=${encodeURIComponent(path)}`,
                (object) => {
                    currentObject = object;
                    // currentObject.material = new THREE.MeshPhongMaterial({ color: 0xaaaaaa, side: THREE.DoubleSide });
                        // Clean up meshes: remove degenerate triangles, compute normals,
                        // enable polygon offset to reduce z-fighting, and make materials
                        // double-sided so faces aren't hidden due to winding.
                        currentObject.traverse((child) => {
                            if (!child.isMesh) return;
                            try {
                                cleanMeshGeometry(child);
                            } catch (e) {
                                console.warn('cleanMeshGeometry failed', e);
                            }
                        });
                    
                    // Update file name display
                    const fileName = path.split('/').pop();
                    document.getElementById('file-name').textContent = `File: ${fileName}`;
                    
                    // Update object info
                    updateObjectInfo(object);
                    
                    // Center the object
                    const box = new THREE.Box3().setFromObject(object);
                    const center = box.getCenter(new THREE.Vector3());
                    object.position.sub(center);
                    scene.add(object);

                    // adjust axes helper scale and position to match object size
                    if (axesHelper) {
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z);
                        const scale = Math.max(1e-3, maxDim);
                        axesHelper.scale.set(scale, scale, scale);
                        // position axes at object center (object was recentered to origin, so center=0)
                        axesHelper.position.copy(object.position);
                        if (axesVisible) {
                            if (!scene.children.includes(axesHelper)) scene.add(axesHelper);
                        }
                    }

                    // create/update box helper if currently visible
                    if (bboxVisible) {
                        if (boxHelper) scene.remove(boxHelper);
                        boxHelper = new THREE.BoxHelper(object, 0xffff00);
                        scene.add(boxHelper);
                    }

                    updateViewMode();

                    // Adjust camera to fit the object
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = camera.fov * (Math.PI / 180);
                    let cameraZ = Math.abs(maxDim / 2 * Math.tan(fov * 2));
                    cameraZ *= 1.5; // zoom out a bit
                    
                    camera.position.z = cameraZ;
                    controls.update();

                    // enable download button now that object is loaded
                    if (downloadBtn) downloadBtn.disabled = false;
                },
                (xhr) => {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                (error) => {
                    console.error('An error happened', error);
                }
            );
        }

        // Remove degenerate triangles, compute normals, and adjust material properties
        function cleanMeshGeometry(mesh) {
            const geom = mesh.geometry;
            if (!geom || !geom.attributes || !geom.attributes.position) return;

            const posAttr = geom.attributes.position;
            const posArray = posAttr.array;

            const vA = new THREE.Vector3();
            const vB = new THREE.Vector3();
            const vC = new THREE.Vector3();
            const ab = new THREE.Vector3();
            const cb = new THREE.Vector3();

            const areaEps = 1e-12; // triangles with area <= this are degenerate

            if (geom.index) {
                const idx = Array.from(geom.index.array);
                const kept = [];
                for (let i = 0; i < idx.length; i += 3) {
                    const ia = idx[i] * 3;
                    const ib = idx[i+1] * 3;
                    const ic = idx[i+2] * 3;
                    vA.set(posArray[ia], posArray[ia+1], posArray[ia+2]);
                    vB.set(posArray[ib], posArray[ib+1], posArray[ib+2]);
                    vC.set(posArray[ic], posArray[ic+1], posArray[ic+2]);
                    ab.subVectors(vB, vA);
                    cb.subVectors(vC, vA);
                    const area2 = ab.cross(cb).lengthSq();
                    if (area2 > areaEps) {
                        kept.push(idx[i], idx[i+1], idx[i+2]);
                    }
                }
                if (kept.length !== idx.length) {
                    geom.setIndex(kept);
                    geom.index.needsUpdate = true;
                }
            } else {
                // non-indexed -> rebuild positions array keeping only non-degenerate triangles
                const newPos = [];
                for (let i = 0; i < posArray.length; i += 9) {
                    vA.set(posArray[i], posArray[i+1], posArray[i+2]);
                    vB.set(posArray[i+3], posArray[i+4], posArray[i+5]);
                    vC.set(posArray[i+6], posArray[i+7], posArray[i+8]);
                    ab.subVectors(vB, vA);
                    cb.subVectors(vC, vA);
                    const area2 = ab.cross(cb).lengthSq();
                    if (area2 > areaEps) {
                        newPos.push(
                            vA.x, vA.y, vA.z,
                            vB.x, vB.y, vB.z,
                            vC.x, vC.y, vC.z
                        );
                    }
                }
                if (newPos.length !== posArray.length) {
                    const newArr = new Float32Array(newPos);
                    geom.setAttribute('position', new THREE.BufferAttribute(newArr, 3));
                }
            }

            // Recompute normals if missing or after re-indexing/cleanup
            try {
                if (!geom.attributes.normal || geom.attributes.normal.count === 0) {
                    geom.computeVertexNormals();
                } else {
                    // recompute in case indices changed
                    geom.computeVertexNormals();
                }
            } catch (e) {
                console.warn('computeVertexNormals failed', e);
            }

            // Ensure material exists and is double-sided; enable polygon offset to
            // reduce z-fighting when overlaying wireframes or duplicate surfaces.
            if (!mesh.material) mesh.material = new THREE.MeshPhongMaterial();
            try {
                if (mesh.material.side === undefined) mesh.material.side = THREE.DoubleSide;
                mesh.material.side = THREE.DoubleSide;
                mesh.material.polygonOffset = true;
                mesh.material.polygonOffsetFactor = 1;
                mesh.material.polygonOffsetUnits = 1;
                mesh.material.needsUpdate = true;
            } catch (e) {
                console.warn('failed to set material flags', e);
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);

        init();

        function handleKeyDown(event) {
            const rotationSpeed = 0.1; // radians per key press

            // View mode shortcuts (J/K/L, case-insensitive) and C toggle for Components
            const key = event.key.toLowerCase();
            if (key === 'c') {
                if (viewModeSelect.value !== 'components') {
                    prevViewMode = viewModeSelect.value;
                    viewModeSelect.value = 'components';
                } else {
                    viewModeSelect.value = prevViewMode || 'surface';
                    prevViewMode = null;
                }
                updateViewMode();
                return;
            }

            if (key === 'j' || key === 'k' || key === 'l') {
                if (key === 'j') viewModeSelect.value = 'surface';
                if (key === 'k') viewModeSelect.value = 'wireframe';
                if (key === 'l') viewModeSelect.value = 'both';
                updateViewMode();
                return;
            }

            // Toggle axes helper with 'x' key
            if (key === 'x') {
                axesVisible = !axesVisible;
                const axesToggleElem = document.getElementById('axes-toggle');
                axesToggleElem.checked = axesVisible;
                if (axesVisible) {
                    if (axesHelper && !scene.children.includes(axesHelper)) scene.add(axesHelper);
                } else {
                    if (axesHelper) scene.remove(axesHelper);
                }
                return;
            }

            // Download shortcut: Shift+D to avoid conflicting with rotation 'd'
            if (event.key === 'D' || (event.key === 'd' && event.shiftKey)) {
                // trigger download if available
                if (downloadBtn && !downloadBtn.disabled) {
                    downloadCurrentObject();
                }
                return;
            }

            // Toggle bounding box with 'b' key
            if (key === 'b') {
                bboxVisible = !bboxVisible;
                if (!bboxVisible) {
                    if (boxHelper) { scene.remove(boxHelper); boxHelper = null; }
                    // clear bbox text
                    document.getElementById('bbox-min').textContent = `BBox min: -`;
                    document.getElementById('bbox-max').textContent = `BBox max: -`;
                    document.getElementById('bbox-size').textContent = `BBox size: -`;
                } else {
                    if (currentObject) {
                        if (boxHelper) scene.remove(boxHelper);
                        boxHelper = new THREE.BoxHelper(currentObject, 0xffff00);
                        scene.add(boxHelper);
                        // update info immediately
                        updateObjectInfo(currentObject);
                    }
                }
                return;
            }

            if (currentObject) {
                switch (event.key) {
                    // Rotation controls
                    case 'a':
                        currentObject.rotation.y -= rotationSpeed;
                        if (wireframeObject) wireframeObject.rotation.y -= rotationSpeed;
                        break;
                    case 'd':
                        currentObject.rotation.y += rotationSpeed;
                        if (wireframeObject) wireframeObject.rotation.y += rotationSpeed;
                        break;
                    case 'w':
                        currentObject.rotation.x -= rotationSpeed;
                        if (wireframeObject) wireframeObject.rotation.x -= rotationSpeed;
                        break;
                    case 's':
                        currentObject.rotation.x += rotationSpeed;
                        if (wireframeObject) wireframeObject.rotation.x += rotationSpeed;
                        break;
                    case 't':
                        currentObject.rotation.z += rotationSpeed;
                        if (wireframeObject) wireframeObject.rotation.z += rotationSpeed;
                        break;
                    case 'g':
                        currentObject.rotation.z -= rotationSpeed;
                        if (wireframeObject) wireframeObject.rotation.z -= rotationSpeed;
                        break;
                }
            }

             // Navigation controls
            switch (event.key) {
                case 'ArrowLeft':
                    if (objectSelect.options.length > 0) {
                        let newIndex = objectSelect.selectedIndex - 1;
                        if (newIndex < 0) {
                            newIndex = objectSelect.options.length - 1;
                        }
                        objectSelect.selectedIndex = newIndex;
                        objectSelect.dispatchEvent(new Event('change'));
                    }
                    break;
                case 'ArrowRight':
                    if (objectSelect.options.length > 0) {
                        let newIndex = objectSelect.selectedIndex + 1;
                        if (newIndex >= objectSelect.options.length) {
                            newIndex = 0;
                        }
                        objectSelect.selectedIndex = newIndex;
                        objectSelect.dispatchEvent(new Event('change'));
                    }
                    break;
            }
        }

        window.addEventListener('keydown', handleKeyDown);
    </script>
</body>
</html>
